+++
title = "Принцип работы nodejs"
date = "2020-09-22T17:30:06+03:00"
tags = ["nodejs", "libuv", "v8", "backend"]
+++

Сегодня копнем внутренний принцип работы **nodejs** и развенчаем пару мифов. **Nodejs** состоит из 3х основных
компонентов:

1. [V8](https://v8docs.nodesource.com/) - движок от гугла для парсинга и исполнения **js**;
2. [libuv](https://libuv.org/) - библиотека, реализующая **event loop**;
3. [node](https://nodejs.org/en/) - сам бинарник, который связывает **v8** и **libuv** и позволяет коду на **js**
работать на сервере.

Я буду много говорить про т.н. **event loop**, поэтому сразу введем его в терминологию. **Event loop** - это, по сути,
бесконечный цикл, который на каждую итерацию обрабатывает произошедшие события. Чтобы цикл был производителен, он
должен работать асинхронно и не блокироваться. Для асинхронной работы так же необходимо передавать колбэк, который
будет вызван по завершению какой-то функции иначе будет невозможно узнать, когда операция закончится.

Для аналогии можно посмотреть на кассу в МакФаке с одной свободной кассой:

- Если кассир будет получать заказ, ждать его приготовления, отдавать клиенту и только потом принимать следующий, то
время обработки очереди клиентов будет достаточно долгое. Цикл обработки **синхронен**;
- Если, кассир будет принимать заказы, отправлять их на приготовление и отдавать когда его отдадут с кухни, принимая в
это же самое время новые заказы, то время обработки сократиться. Цикл обработки **асинхроннен**. Однако если найдется
клиент, который будет задавать много вопросов или спорить с кассиром, то цикл будет **заблокирован**.

В нашей теме с **nodejs**, **event loop** предоставляет только **libuv**, это единственный **event loop**, который
работает в **nodejs**. V8, конечно, имеет [реализацию по умолчанию](https://github.com/v8/v8/blob/6.8.275.32/src/libplatform/default-platform.cc),
но nodejs [заменяет её](https://github.com/nodejs/node/blob/v10.x/src/node_platform.cc) на **libuv**, а **chromium** -
на **libevent**.

**Nodejs не однопоточен! Однопоточен только Event loop!**

**V8** использует несколько потоков для **GC**, а **libuv** использует **thread pool** для выполнения некоторых
синхронных операций и системных вызовов.

**Thread pool** - это вечноживущие потоки, на которые перебрасываются операции, которые могут заблокировать
**event loop**. А что это за операции такие? К ним относятся: вызов *dns.lookup* (даже если он асинхронный с точки
зрения **JS**), некоторая криптография, работа с файловой системой. После того, как операция закончится на потоке,
колбэк, который необходимо выполнить по завершению, будет помещен в очередь в **event loop**. Размер пула равен
переменной окружения `UV_THREADPOOL_SIZE` (по умолчанию **4**).

**Nodejs** использует только 1 **event loop** (за исключением *worker threads*) и поскольку это просто синхронный цикл,
то он ограничен одним потоком. Возникает вопрос - а почему бы не использовать несколько циклов? Тогда приложение могло
бы само масштабироваться на несколько ядер. Ведь **libuv** позволяет запустить сколько душе угодно **event loop**'ов.
Тут все не так просто. Даже если мы будем использовать несколько циклов на нескольких ядрах, то **V8 потоко НЕ
безопасный** и доступ к нему придется синхронизировать, а это будет очень медленно.

Я оставлю несколько полезных ссылок:

- [Репозиторий с примерами прямого использования libuv и комментариями](https://github.com/danbev/learning-libuv)
- [Issue в котором на примере рассказывается вся цепочка вызовов сишного кода на примере fs.readFile](https://github.com/libuv/help/issues/62)
- [Node.js C++ codebase README](https://github.com/nodejs/node/blob/master/src/README.md)
- [Concurrent Servers](https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/)
- [Nonblocking I/O](https://medium.com/@copyconstruct/nonblocking-i-o-99948ad7c957)
